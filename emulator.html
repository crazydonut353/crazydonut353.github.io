<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Page Title</title>
</head>
<body>

<style>
table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}

td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}
</style>

<h1>ChudCPU emulator</h1>
<p id="out">This is a paragraph.</p>
<div id="ui">
	<button id="next">next instruction</button><br /><br />
</div>
<script>
/**
 * Extracts a sequence of bits from a 16-bit number.
 * 
 * @param {number} number The original 16-bit integer.
 * @param {number} position The starting position of the bits (0-indexed from the right).
 * @param {number} length The number of bits to extract (in this case, 2).
 * @returns {number} The extracted bits as a new number.
 */
function extractBits(number, position, length) {
  // 1. Shift the desired bits to the least significant positions (rightmost)
  // Use >>> for unsigned right shift, which is generally safer for bitwise operations in JS.
  const shifted = number >>> position;

  // 2. Create a mask with 'length' number of ones (e.g., 2 bits = 0b11 or 3 in decimal)
  const mask = (1 << length) - 1; // For 2 bits: (1 << 2) - 1 = 4 - 1 = 3 (0b11)

  // 3. Apply the mask using bitwise AND to isolate the target bits
  const result = shifted & mask;

  return result;
}

class Counter {
constructor() {
    	this.register = new Int16Array(1);
    }
    
    update(st, X) {
    	if(st) {
        	this.register[0] = X;
        } else {
        	this.register[0] = this.register[0] + 1;
        }
    }
    
    f_reg() {
    	return this.register[0];
    }
}
class CM {
	constructor() {
    	this.memory = new Int16Array(256);
        this.registers = new Int16Array(2); // [A, D]
        this.memory[0] = 3;
    }
    
    genTable(length) {
    	let table = [["RAM"],["A","B", "-"], [this.registers[0].toString(2), this.registers[1].toString(2), "-"], ["index", "value", "-"]]
        for(let i = 0; i < length; i++) {
        	table.push([i, this.memory[i].toString(2), "-"]);
        }
        return table;
    }
    
    update(regs, X) {
    	if(extractBits(regs, 2, 1)) { // idk about this... 
        	// hope this doesnt mess anything up
        	this.memory[this.registers[0]] = X;
        }
    	if(extractBits(regs, 0, 1)) {
        	this.registers[0] = X;
        }
        if(extractBits(regs, 1, 1)) {
        	this.registers[1] = X;
        }
    }
    
    f_regs() {
    	return new Int16Array([
        	this.registers[0],
            this.registers[1],
            this.memory[this.registers[0]]
        ]);
    }
}

class ROM {
	constructor() {
    	this.memory = new Int16Array(256);
    }

	genTable(length) {
    	let table = [["ROM"], ["index", "value", "Assembler equivelent"]]
        for(let i = 0; i < length; i++) {
        	table.push([i, this.memory[i].toString(2), "-"]);
        }
        return table;
    }
    
    s_mem(ad, X) {
    	this.memory[ad] = X;
    }
    
    f_reg(ad) {
    	return this.memory[ad];
    }
}

function createTable(tableData) {
  var table = document.createElement('table');
  var tableBody = document.createElement('tbody');

  tableData.forEach(function(rowData) {
    var row = document.createElement('tr');

    rowData.forEach(function(cellData) {
      var cell = document.createElement('td');
      cell.appendChild(document.createTextNode(cellData));
      row.appendChild(cell);
    });

    tableBody.appendChild(row);
  });

  table.appendChild(tableBody);
  document.body.appendChild(table);

	return table;
}


function HA(A, B) {
	return [A ^ B, A & B];
}
function FA(A, B, C) {
	return [A ^ (B ^ C), (A&(B ^ C))|(B&C)];
}
function A16(A, B) {
	return A + B;
}
function S16(A, B) {
 	return ~(A16(~A, B));
}
function SLCT(S, D1, D0) {
	if(S == 0x1) {
    	return D1;
    } else {
    	return D0;
    }
}
function SLCT4(S, D3, D2, D1, D0) {
	if(S == 3) {
    	return D3;
    }
    if(S == 2) {
    	return D2;
    }
    if(S == 1) {
    	return D1;
    }
    if(S == 0) {
    	return D0;
    }
}

// who even needs those funcs? just tryina learn
function LU(op, X, Y) {
	if(op == 0) {
    	return X & Y;
    }
    if(op == 1) {
    	return X | Y;
    }
    if(op == 2) {
    	return X ^ Y;
    }
    if(op == 3) {
    	return ~X;
    }
}

function AU(op, X, Y) {
	if(op == 0) {
    	return X + Y;
    }
    if(op == 1) {
    	return S16(X, Y); // could use proprietery funcs... dont want errors
    }
    if(op == 2) {
    	return X + 1;
    }
    if(op == 3) {
    	return X - 1;
    }
}

function ALU(u, op, zx, sw, X, Y) {
	let nx;
    let ny;
    
    sw ? nx = Y : nx = X;
    sw ? ny = X : ny = Y;
    
    zx ? nx = 0 : null;
    
	if(u) {
    	return AU(op, X, Y);
    } else {
    	return LU(op, X, Y);
    }
}

function COND(lt, eq, gt, X) { // havent cheecked this
	return ((lt&(X<0)) | (eq&(X==0))) | (gt&(X>0));
}

function ALU_I(I, A, D, AR) { // Man i hope this works. too lazy to test
	if(extractBits(I, 12, 1)) {
    	const out = ALU(
            	extractBits(I, 10, 1), // unit
                extractBits(I, 8, 2), // operation
                extractBits(I, 7, 1), // zx ( lefthand to zero )
                extractBits(I, 6, 1), // sw ( switch X and Y, fp )
                D, // X input is D register
                AR // Y input is A* since bit 12 is true
            );
    
    	return new Int16Array([
        	out,
            extractBits(I, 3, 3), // destination (kinda useless in em)
            COND(
            	extractBits(I, 2, 1),
                extractBits(I, 1, 1),
                extractBits(I, 0, 1),
                out // result
            )// j
        ]);
    } else {
    	const out = ALU(
            	extractBits(I, 10, 1), // unit
                extractBits(I, 8, 2), // operation
                extractBits(I, 7, 1), // zx ( lefthand to zero )
                extractBits(I, 6, 1), // sw ( switch X and Y, fp )
                D, // X input is D register
                A // Y input is A since bit 12 is false
            );
    
    	return new Int16Array([
        	out,
            extractBits(I, 3, 3), // destination (kinda useless in em)
            COND(
            	extractBits(I, 2, 1),
                extractBits(I, 1, 1),
                extractBits(I, 0, 1),
                out // result
            )// j
        ]);
    }
}

function CPU(I, A, D, AR) { // simple. just mask for operation select
	if(extractBits(I, 15, 1)) {
    	return ALU_I(I, A, D, AR);
    } else {
    	return [I, 0x64, 0];
    }
}

function COMPUTER(combinedMem, programMem, programCounter) {
	const G = combinedMem.f_regs();
	const R = CPU(programMem.f_reg(programCounter.f_reg()), G[0], G[1], G[2]);
	programMem.update(R[1], R[0]);
	programCounter.update(R[2], G[0]);
}

function update(combinedMem, programMem, programCounter, ui, table) {
	COMPUTER(combinedMem, programMem, programCounter);
	// update ui here
	// update ram table here
	document.getElementById("out").innerText = combinedMem.f_regs();
}

function probe(value) {
	return value.toString();
}

document.getElementById("out").innerText += CPU(0x0438, 0x0005, 0x0001, 13)[0].toString(2)

const nums = new Int16Array(2);
nums[0] = 1;
nums[1] = 1;

try {
	const combinedMem = new CM();
	const programMem = new ROM();
	const programCounter = new Counter();
	
	const nextInstructionEl = document.getElementById("next");
	let b = createTable(programMem.genTable(10));

	nextInstructionEl.addEventListener((e)=>update(combinedMem, programMem, programCounter), "click");
} catch(e) {
	document.getElementById("out").innerText = e;
}
</script>

</body>
</html>

