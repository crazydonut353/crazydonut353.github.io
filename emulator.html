<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ChudCPU Emulator</title>
<style>
  body {
    font-family: "Fira Code", monospace;
    background-color: #1e1e2f;
    color: #e0e0e0;
    padding: 20px;
  }
  h1 {
    color: #73d7ff;
  }
  .container {
    display: flex;
    gap: 20px;
  }
  .panel {
    background-color: #2b2b3c;
    padding: 15px;
    border-radius: 8px;
    flex: 1;
    position: relative;
  }
  .rom-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    border: 1px solid #444;
    padding: 6px;
    text-align: center;
  }
  tr.active {
    background-color: #394b70;
  }
  input.rom-input {
    width: 100%;
    background: transparent;
    color: #c0ffa0;
    border: none;
    text-align: center;
  }
  input.rom-input:focus {
    outline: none;
    background-color: #333a4f;
  }
  button {
    background-color: #444c68;
    border: none;
    color: white;
    padding: 8px 14px;
    margin-right: 10px;
    border-radius: 6px;
    cursor: pointer;
  }
  button:hover {
    background-color: #5b6ba1;
  }

  /* Right side split layout */
  .right-box {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  .subpanel {
    background-color: #33334a;
    padding: 10px;
    border-radius: 6px;
  }
  canvas {
    background-color: #111;
    border: 1px solid #555;
    display: block;
    margin-top: 10px;
  }

  /* === Collapsible Converter Panel === */
  /* === Collapsible Converter Panel (scrollable) === */
#converterPanel {
  position: fixed;
  top: 60px;
  right: -260px;
  width: 260px;
  height: 80vh; /* gives it a max visible height */
  background-color: #2f2f46;
  border-radius: 8px 0 0 8px;
  padding: 10px;
  font-size: 13px;
  transition: right 0.3s ease-in-out;
  box-shadow: -2px 0 6px rgba(0,0,0,0.4);
  z-index: 100;
  overflow-y: auto; /* enables scrolling inside */
}

/* Scrollbar styling for dark theme */
#converterPanel::-webkit-scrollbar {
  width: 6px;
}
#converterPanel::-webkit-scrollbar-thumb {
  background-color: #555;
  border-radius: 4px;
}
#converterPanel::-webkit-scrollbar-thumb:hover {
  background-color: #777;
}

#converterPanel.open {
  right: 0;
}


  #toggleConverter {
    position: fixed;
    top: 70px;
    right: 0;
    background-color: #444c68;
    color: #fff;
    border-radius: 6px 0 0 6px;
    padding: 6px 10px;
    cursor: pointer;
    transition: background-color 0.2s;
    z-index: 101;
  }
  #toggleConverter:hover {
    background-color: #5b6ba1;
  }

  #converterPanel input {
    width: 100%;
    margin-top: 5px;
    padding: 4px;
    font-family: inherit;
    background: #1d1d2b;
    border: 1px solid #555;
    color: #9fffa0;
    text-align: center;
  }
  #converterPanel .output {
    margin-top: 8px;
    background: #222238;
    padding: 4px;
    border-radius: 4px;
    text-align: center;
  }

  #flagTable, #aluTable, #destTable, #jumpTable {
    width: 100%;
    margin-top: 6px;
    font-size: 12px;
  }
  #flagTable th, #aluTable th, #destTable th, #jumpTable th {
    background-color: #3b3b55;
  }
  h3 {
    margin: 10px 0 5px;
    color: #9ad8ff;
  }
</style>
</head>
<body>

<h1>ðŸ§  ChudCPU Emulator</h1>

<div class="container">
  <div class="panel">
    <div class="rom-header">
      <h2>ROM (Program Memory)</h2>
      <div>
        <button id="prevPage">â—€ Page</button>
        <button id="nextPage">Page â–¶</button>
      </div>
    </div>
    <table id="romTable">
      <thead>
        <tr><th>Address</th><th>Instruction (hex)</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="panel right-box">
    <div class="subpanel">
      <h2>CPU State</h2>
      <p><b>Register A:</b> <span id="regA">0</span></p>
      <p><b>Register D:</b> <span id="regD">0</span></p>
      <p><b>Memory[A]:</b> <span id="memA">0</span></p>
      <p><b>Program Counter:</b> <span id="pc">0</span></p>

      <button id="next">Next Instruction</button>
      <button id="reset">Reset</button>
    </div>

    <div class="subpanel">
      <h2>Digital Peripherals</h2>
      <canvas id="display" width="128" height="128"></canvas>
      <div id="inputArea"></div>
    </div>
  </div>
</div>

<!-- === Collapsible binaryâ†’hex converter panel === -->
<div id="converterPanel">
  <h3>Bit Flags</h3>
  <table id="flagTable">
    <tr><th>Bit</th><th>Meaning</th></tr>
    <tr><td>15</td><td>Instruction Type (1 = C, 0 = A)</td></tr>
    <tr><td>12</td><td>Use A register</td></tr>
    <tr><td>10â€“11</td><td>ALU Operation</td></tr>
    <tr><td>7</td><td>Zero X input</td></tr>
    <tr><td>6</td><td>Swap X/Y inputs</td></tr>
    <tr><td>3â€“5</td><td>Destination bits</td></tr>
    <tr><td>0â€“2</td><td>Jump condition bits</td></tr>
  </table>

  <h3>ALU Operations</h3>
  <table id="aluTable">
    <tr><th>op (bits 9â€“8)</th><th>Meaning</th></tr>
    <tr><td>00</td><td>X + Y</td></tr>
    <tr><td>01</td><td>~(~X + Y)</td></tr>
    <tr><td>10</td><td>X + 1</td></tr>
    <tr><td>11</td><td>X - 1</td></tr>
  </table>

  <h3>Destination Bits</h3>
  <table id="destTable">
    <tr><th>Bits</th><th>Destination</th></tr>
    <tr><td>Bit 5</td><td>â†’ Memory[A]</td></tr>
    <tr><td>Bit 4</td><td>â†’ D Register</td></tr>
    <tr><td>Bit 3</td><td>â†’ A Register</td></tr>
  </table>

  <h3>Jump Conditions</h3>
  <table id="jumpTable">
    <tr><th>Bits (2â€“0)</th><th>Condition</th></tr>
    <tr><td>001</td><td>JGT (out &gt; 0)</td></tr>
    <tr><td>010</td><td>JEQ (out == 0)</td></tr>
    <tr><td>100</td><td>JLT (out &lt; 0)</td></tr>
    <tr><td>011</td><td>JGE</td></tr>
    <tr><td>101</td><td>JNE</td></tr>
    <tr><td>111</td><td>JMP (always)</td></tr>
  </table>

  <h3>Binary â†’ Hex</h3>
  <input id="binaryInput" type="text" placeholder="Enter binary (e.g. 1010101010101010)">
  <div class="output" id="hexOutput">Hex: 0x0</div>
</div>

<div id="toggleConverter">â—€ Tools</div>

<script>
// bit extraction helper
function extractBits(number, position, length) {
  return (number >>> position) & ((1 << length) - 1);
}

class Counter {
  constructor() { this.register = new Int16Array(1); }
  update(st, X) { this.register[0] = st ? X : this.register[0] + 1; }
  f_reg() { return this.register[0]; }
}

class CM {
  constructor() {
    this.memory = new Int16Array(65536);
    this.registers = new Int16Array(2);
  }
  update(regs, X) {
    if (extractBits(regs, 2, 1)) this.memory[this.registers[0]] = X;
    if (extractBits(regs, 0, 1)) this.registers[0] = X;
    if (extractBits(regs, 1, 1)) this.registers[1] = X;
  }
  f_regs() {
    return new Int16Array([
      this.registers[0],
      this.registers[1],
      this.memory[this.registers[0]]
    ]);
  }
}

class ROM {
  constructor() { this.memory = new Int16Array(256); }
  s_mem(ad, X) { this.memory[ad] = X; }
  f_reg(ad) { return this.memory[ad]; }
}

function LU(op, X, Y) {
  return [X & Y, X | Y, X ^ Y, ~X][op];
}

function AU(op, X, Y) {
  if (op == 0) return X + Y;
  if (op == 1) return ~(~X + Y);
  if (op == 2) return X + 1;
  if (op == 3) return X - 1;
}

function ALU(u, op, zx, sw, X, Y) {
  let nx = sw ? Y : X;
  let ny = sw ? X : Y;
  if (zx) nx = 0;
  return u ? AU(op, nx, ny) : LU(op, nx, ny);
}

function COND(lt, eq, gt, X) {
  return ((lt & (X < 0)) | (eq & (X == 0)) | (gt & (X > 0)));
}

function ALU_I(I, A, D, AR) {
  const useAreg = extractBits(I, 12, 1);
  const out = ALU(
    extractBits(I, 10, 1),
    extractBits(I, 8, 2),
    extractBits(I, 7, 1),
    extractBits(I, 6, 1),
    D,
    useAreg ? AR : A
  );
  return new Int16Array([
    out,
    extractBits(I, 3, 3),
    COND(extractBits(I, 2, 1), extractBits(I, 1, 1), extractBits(I, 0, 1), out)
  ]);
}

function CPU(I, A, D, AR) {
  if (extractBits(I, 15, 1)) return ALU_I(I, A, D, AR);
  return [I, 0x1, 0];
}

function COMPUTER(cm, rom, pc) {
  const G = cm.f_regs();
  const R = CPU(rom.f_reg(pc.f_reg()), G[0], G[1], G[2]);
  cm.update(R[1], R[0]);
  pc.update(R[2], G[0]);
}

// === UI ===
const rom = new ROM();
const cm = new CM();
const pc = new Counter();

const romTable = document.querySelector("#romTable tbody");
const regAEl = document.getElementById("regA");
const regDEl = document.getElementById("regD");
const memAEl = document.getElementById("memA");
const pcEl = document.getElementById("pc");

const display = document.getElementById("display");
const ctx = display.getContext("2d");

let currentPage = 0;
const PAGE_SIZE = 16;

function renderROM() {
  romTable.innerHTML = "";
  const start = currentPage * PAGE_SIZE;
  const end = start + PAGE_SIZE;

  for (let i = start; i < end; i++) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i}</td>
      <td><input class="rom-input" data-addr="${i}" value="${rom.memory[i].toString(16)}" /></td>
    `;
    romTable.appendChild(tr);
  }
}

function renderDisplay() {
  const imgData = ctx.createImageData(display.width, display.height);
  for (let i = 0; i < display.width * display.height; i++) {
    const pixelOn = cm.memory[16384 + i] & 1;
    const idx = i * 4;
    imgData.data[idx] = pixelOn ? 255 : 0;
    imgData.data[idx + 1] = pixelOn ? 255 : 0;
    imgData.data[idx + 2] = pixelOn ? 255 : 0;
    imgData.data[idx + 3] = 255;
  }
  ctx.putImageData(imgData, 0, 0);
}

function refreshUI() {
  const regs = cm.f_regs();
  regAEl.textContent = regs[0];
  regDEl.textContent = regs[1];
  memAEl.textContent = regs[2];
  pcEl.textContent = pc.f_reg();

  [...romTable.children].forEach(tr => tr.classList.remove("active"));
  const relIndex = pc.f_reg() - currentPage * PAGE_SIZE;
  if (relIndex >= 0 && relIndex < PAGE_SIZE) {
    romTable.children[relIndex].classList.add("active");
  }

  renderDisplay();
}

// === Binary â†’ Hex converter logic ===
document.getElementById("binaryInput").addEventListener("input", e => {
  const val = e.target.value.trim();
  const output = document.getElementById("hexOutput");
  if (/^[01]+$/.test(val)) {
    const hex = parseInt(val, 2).toString(16).toUpperCase();
    output.textContent = `Hex: 0x${hex}`;
  } else {
    output.textContent = "Hex: Invalid input";
  }
});

// Collapsible toggle
const toggle = document.getElementById("toggleConverter");
const panel = document.getElementById("converterPanel");
toggle.addEventListener("click", () => {
  const open = panel.classList.toggle("open");
  toggle.textContent = open ? "Tools â–¶" : "â—€ Tools";
});

romTable.addEventListener("input", e => {
  if (e.target.classList.contains("rom-input")) {
    const addr = parseInt(e.target.dataset.addr);
    const val = parseInt(e.target.value, 16);
    rom.s_mem(addr, val || 0);
  }
});

document.getElementById("next").addEventListener("click", () => {
  COMPUTER(cm, rom, pc);
  refreshUI();
});

document.getElementById("reset").addEventListener("click", () => {
  pc.register[0] = 0;
  cm.registers[0] = 0;
  cm.registers[1] = 0;
  refreshUI();
});

document.getElementById("nextPage").addEventListener("click", () => {
  if ((currentPage + 1) * PAGE_SIZE < rom.memory.length) {
    currentPage++;
    renderROM();
    refreshUI();
  }
});
document.getElementById("prevPage").addEventListener("click", () => {
  if (currentPage > 0) {
    currentPage--;
    renderROM();
    refreshUI();
  }
});

renderROM();
refreshUI();
</script>
</body>
</html>
